<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/Linalg/ComprehensiveBufferize/ComprehensiveBufferize.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">14.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a class="el" href="dir_8edb792440615361a0811a7329611599.html">Linalg</a></li><li class="navelem"><a class="el" href="dir_e44b8cea2a527cfa1a475cbe450594ac.html">ComprehensiveBufferize</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ComprehensiveBufferize.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="ComprehensiveBufferize_8h_source.html">mlir/Dialect/Linalg/ComprehensiveBufferize/ComprehensiveBufferize.h</a>&quot;</code><br />
<code>#include &lt;random&gt;</code><br />
<code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="BufferizableOpInterface_8h_source.html">mlir/Dialect/Linalg/ComprehensiveBufferize/BufferizableOpInterface.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="MemRef_8h_source.html">mlir/Dialect/MemRef/IR/MemRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2SCF_2SCF_8h_source.html">mlir/Dialect/SCF/SCF.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="StaticValueUtils_8h_source.html">mlir/Dialect/Utils/StaticValueUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="VectorOps_8h_source.html">mlir/Dialect/Vector/VectorOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AsmState_8h_source.html">mlir/IR/AsmState.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="BlockAndValueMapping_8h_source.html">mlir/IR/BlockAndValueMapping.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Operation_8h_source.html">mlir/IR/Operation.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TypeUtilities_8h_source.html">mlir/IR/TypeUtilities.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="InferTypeOpInterface_8h_source.html">mlir/Interfaces/InferTypeOpInterface.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="include_2mlir_2Pass_2Pass_8h_source.html">mlir/Pass/Pass.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PassManager_8h_source.html">mlir/Pass/PassManager.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="BufferUtils_8h_source.html">mlir/Transforms/BufferUtils.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/DenseSet.h&quot;</code><br />
<code>#include &quot;llvm/ADT/ScopeExit.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SetVector.h&quot;</code><br />
<code>#include &quot;llvm/ADT/TypeSwitch.h&quot;</code><br />
<code>#include &quot;llvm/Support/FormatVariadic.h&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for ComprehensiveBufferize.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="ComprehensiveBufferize_8cpp__incl.png" border="0" usemap="#lib_2Dialect_2Linalg_2ComprehensiveBufferize_2ComprehensiveBufferize_8cpp" alt=""/></div>
<map name="lib_2Dialect_2Linalg_2ComprehensiveBufferize_2ComprehensiveBufferize_8cpp" id="lib_2Dialect_2Linalg_2ComprehensiveBufferize_2ComprehensiveBufferize_8cpp">
<area shape="rect" id="node2" href="ComprehensiveBufferize_8h.html" title="mlir/Dialect/Linalg\l/ComprehensiveBufferize\l/ComprehensiveBufferize.h" alt="" coords="4081,109,4280,165"/>
<area shape="rect" id="node3" href="BufferizableOpInterface_8h.html" title="mlir/Dialect/Linalg\l/ComprehensiveBufferize\l/BufferizableOpInterface.h" alt="" coords="3990,213,4182,269"/>
<area shape="rect" id="node4" href="BlockAndValueMapping_8h.html" title="mlir/IR/BlockAndValueMapping.h" alt="" coords="3535,332,3768,359"/>
<area shape="rect" id="node8" href="Operation_8h.html" title="mlir/IR/Operation.h" alt="" coords="4376,585,4521,612"/>
<area shape="rect" id="node19" href="InferTypeOpInterface_8h.html" title="mlir/Interfaces/InferType\lOpInterface.h" alt="" coords="2598,325,2779,366"/>
<area shape="rect" id="node22" href="StaticValueUtils_8h.html" title="mlir/Dialect/Utils\l/StaticValueUtils.h" alt="" coords="3027,421,3169,463"/>
<area shape="rect" id="node26" href="AffineOps_8h.html" title="mlir/Dialect/Affine\l/IR/AffineOps.h" alt="" coords="3463,117,3603,158"/>
<area shape="rect" id="node35" href="MemRef_8h.html" title="mlir/Dialect/MemRef\l/IR/MemRef.h" alt="" coords="1838,117,1993,158"/>
<area shape="rect" id="node40" href="Dialect_2SCF_2SCF_8h.html" title="mlir/Dialect/SCF/SCF.h" alt="" coords="968,228,1132,255"/>
<area shape="rect" id="node42" href="VectorOps_8h.html" title="mlir/Dialect/Vector\l/VectorOps.h" alt="" coords="1671,117,1813,158"/>
<area shape="rect" id="node43" href="AsmState_8h.html" title="mlir/IR/AsmState.h" alt="" coords="4654,228,4798,255"/>
<area shape="rect" id="node44" href="TypeUtilities_8h.html" title="mlir/IR/TypeUtilities.h" alt="" coords="4873,511,5035,537"/>
<area shape="rect" id="node45" href="include_2mlir_2Pass_2Pass_8h.html" title="mlir/Pass/Pass.h" alt="" coords="5,511,132,537"/>
<area shape="rect" id="node46" href="PassManager_8h.html" title="mlir/Pass/PassManager.h" alt="" coords="157,511,338,537"/>
<area shape="rect" id="node47" href="BufferUtils_8h.html" title="mlir/Transforms/BufferUtils.h" alt="" coords="2515,124,2724,151"/>
<area shape="rect" id="node14" href="Dialect_2Tensor_2IR_2Tensor_8h.html" title="mlir/Dialect/Tensor\l/IR/Tensor.h" alt="" coords="2438,221,2582,262"/>
<area shape="rect" id="node23" href="Value_8h.html" title="mlir/IR/Value.h" alt="" coords="4294,429,4411,455"/>
<area shape="rect" id="node5" href="Builders_8h.html" title="mlir/IR/Builders.h" alt="" coords="2532,429,2667,455"/>
<area shape="rect" id="node9" href="IR_2BuiltinTypes_8h.html" title="mlir/IR/BuiltinTypes.h" alt="" coords="2793,429,2953,455"/>
<area shape="rect" id="node10" href="Support_2LLVM_8h.html" title="mlir/Support/LLVM.h" alt="" coords="3355,511,3505,537"/>
<area shape="rect" id="node6" href="OpDefinition_8h.html" title="mlir/IR/OpDefinition.h" alt="" coords="2230,511,2393,537"/>
<area shape="rect" id="node7" href="IR_2Dialect_8h.html" title="mlir/IR/Dialect.h" alt="" coords="467,585,593,612"/>
<area shape="rect" id="node15" href="Arithmetic_8h.html" title="mlir/Dialect/Arithmetic\l/IR/Arithmetic.h" alt="" coords="1947,325,2118,366"/>
<area shape="rect" id="node16" href="CastInterfaces_8h.html" title="mlir/Interfaces/CastInterfaces.h" alt="" coords="2230,429,2457,455"/>
<area shape="rect" id="node17" href="SideEffectInterfaces_8h.html" title="mlir/Interfaces/SideEffect\lInterfaces.h" alt="" coords="1817,421,2003,463"/>
<area shape="rect" id="node18" href="ControlFlowInterfaces_8h.html" title="mlir/Interfaces/ControlFlow\lInterfaces.h" alt="" coords="1573,325,1772,366"/>
<area shape="rect" id="node21" href="ViewLikeInterface_8h.html" title="mlir/Interfaces/ViewLike\lInterface.h" alt="" coords="2905,325,3085,366"/>
<area shape="rect" id="node20" href="Attributes_8h.html" title="mlir/IR/Attributes.h" alt="" coords="835,429,980,455"/>
<area shape="rect" id="node27" href="AffineMemoryOpInterfaces_8h.html" title="mlir/Dialect/Affine\l/IR/AffineMemoryOpInterfaces.h" alt="" coords="3158,221,3387,262"/>
<area shape="rect" id="node28" href="IR_2AffineMap_8h.html" title="mlir/IR/AffineMap.h" alt="" coords="3313,332,3459,359"/>
<area shape="rect" id="node30" href="Ops_8h.html" title="mlir/Dialect/StandardOps\l/IR/Ops.h" alt="" coords="2127,221,2312,262"/>
<area shape="rect" id="node32" href="LoopLikeInterface_8h.html" title="mlir/Interfaces/LoopLike\lInterface.h" alt="" coords="1023,325,1202,366"/>
<area shape="rect" id="node31" href="CallInterfaces_8h.html" title="mlir/Interfaces/CallInterfaces.h" alt="" coords="1327,332,1549,359"/>
<area shape="rect" id="node36" href="ReshapeOpsUtils_8h.html" title="mlir/Dialect/Utils\l/ReshapeOpsUtils.h" alt="" coords="3244,421,3392,463"/>
<area shape="rect" id="node37" href="CopyOpInterface_8h.html" title="mlir/Interfaces/CopyOpInterface.h" alt="" coords="567,429,810,455"/>
</map>
</div>
</div>
<p><a href="ComprehensiveBufferize_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1comprehensive__bufferize_1_1arith__ext_1_1ConstantOpInterface.html">mlir::linalg::comprehensive_bufferize::arith_ext::ConstantOpInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1comprehensive__bufferize_1_1scf__ext_1_1IfOpInterface.html">mlir::linalg::comprehensive_bufferize::scf_ext::IfOpInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1comprehensive__bufferize_1_1scf__ext_1_1ForOpInterface.html">mlir::linalg::comprehensive_bufferize::scf_ext::ForOpInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1comprehensive__bufferize_1_1scf__ext_1_1YieldOpInterface.html">mlir::linalg::comprehensive_bufferize::scf_ext::YieldOpInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1comprehensive__bufferize_1_1std__ext_1_1CallOpInterface.html">mlir::linalg::comprehensive_bufferize::std_ext::CallOpInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1comprehensive__bufferize_1_1std__ext_1_1ReturnOpInterface.html">mlir::linalg::comprehensive_bufferize::std_ext::ReturnOpInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1comprehensive__bufferize_1_1tensor__ext_1_1CastOpInterface.html">mlir::linalg::comprehensive_bufferize::tensor_ext::CastOpInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1comprehensive__bufferize_1_1tensor__ext_1_1DimOpInterface.html">mlir::linalg::comprehensive_bufferize::tensor_ext::DimOpInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1comprehensive__bufferize_1_1tensor__ext_1_1ExtractSliceOpInterface.html">mlir::linalg::comprehensive_bufferize::tensor_ext::ExtractSliceOpInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1comprehensive__bufferize_1_1tensor__ext_1_1ExtractOpInterface.html">mlir::linalg::comprehensive_bufferize::tensor_ext::ExtractOpInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1comprehensive__bufferize_1_1tensor__ext_1_1InsertSliceOpInterface.html">mlir::linalg::comprehensive_bufferize::tensor_ext::InsertSliceOpInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1comprehensive__bufferize_1_1vector__ext_1_1TransferReadOpInterface.html">mlir::linalg::comprehensive_bufferize::vector_ext::TransferReadOpInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1comprehensive__bufferize_1_1vector__ext_1_1TransferWriteOpInterface.html">mlir::linalg::comprehensive_bufferize::vector_ext::TransferWriteOpInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html">mlir</a></td></tr>
<tr class="memdesc:namespacemlir"><td class="mdescLeft">&#160;</td><td class="mdescRight">Include the generated interface declarations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1linalg"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html">mlir::linalg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1linalg_1_1comprehensive__bufferize"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg_1_1comprehensive__bufferize.html">mlir::linalg::comprehensive_bufferize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1linalg_1_1comprehensive__bufferize_1_1arith__ext"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg_1_1comprehensive__bufferize_1_1arith__ext.html">mlir::linalg::comprehensive_bufferize::arith_ext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1linalg_1_1comprehensive__bufferize_1_1scf__ext"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg_1_1comprehensive__bufferize_1_1scf__ext.html">mlir::linalg::comprehensive_bufferize::scf_ext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1linalg_1_1comprehensive__bufferize_1_1std__ext"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg_1_1comprehensive__bufferize_1_1std__ext.html">mlir::linalg::comprehensive_bufferize::std_ext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1linalg_1_1comprehensive__bufferize_1_1tensor__ext"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg_1_1comprehensive__bufferize_1_1tensor__ext.html">mlir::linalg::comprehensive_bufferize::tensor_ext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1linalg_1_1comprehensive__bufferize_1_1vector__ext"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg_1_1comprehensive__bufferize_1_1vector__ext.html">mlir::linalg::comprehensive_bufferize::vector_ext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;comprehensive-module-<a class="el" href="ComprehensiveBufferize_8cpp.html#ad7a5940d2aef65c5064fd6609fa9ec7b">bufferize</a>&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0bb487c37194ac844a13205a7edcefc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#ae0bb487c37194ac844a13205a7edcefc">DBGS</a>()&#160;&#160;&#160;(llvm::dbgs() &lt;&lt; '[' &lt;&lt; <a class="el" href="Transforms_2Utils_2Utils_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a> &lt;&lt; &quot;] &quot;)</td></tr>
<tr class="separator:ae0bb487c37194ac844a13205a7edcefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb7bbd2151d1599f0a2a4dd7be89253"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#aebb7bbd2151d1599f0a2a4dd7be89253">LDBG</a>(X)&#160;&#160;&#160;LLVM_DEBUG(<a class="el" href="VectorTransferOpTransforms_8cpp.html#ae0bb487c37194ac844a13205a7edcefc">DBGS</a>() &lt;&lt; X)</td></tr>
<tr class="separator:aebb7bbd2151d1599f0a2a4dd7be89253"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2d3c9a4bae960942ab47f607c4356d2f"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#a2d3c9a4bae960942ab47f607c4356d2f">printOperationInfo</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, bool prefix)</td></tr>
<tr class="memdesc:a2d3c9a4bae960942ab47f607c4356d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the operation name and bufferization information.  <a href="#a2d3c9a4bae960942ab47f607c4356d2f">More...</a><br /></td></tr>
<tr class="separator:a2d3c9a4bae960942ab47f607c4356d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc47e96095baa9f513e9dce23429adb"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#a5fc47e96095baa9f513e9dce23429adb">printValueInfo</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, bool prefix)</td></tr>
<tr class="memdesc:a5fc47e96095baa9f513e9dce23429adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the bufferization information for the defining op or block argument.  <a href="#a5fc47e96095baa9f513e9dce23429adb">More...</a><br /></td></tr>
<tr class="separator:a5fc47e96095baa9f513e9dce23429adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3f4227b727bd0d4df109e86e0b1bab"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#a5d3f4227b727bd0d4df109e86e0b1bab">isaTensor</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> t)</td></tr>
<tr class="separator:a5d3f4227b727bd0d4df109e86e0b1bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e21858574e633315d8988d5ebcf46f5"><td class="memItemLeft" align="right" valign="top">static FuncOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#a8e21858574e633315d8988d5ebcf46f5">getCalledFunction</a> (CallOpInterface callOp)</td></tr>
<tr class="memdesc:a8e21858574e633315d8988d5ebcf46f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the FuncOp called by <code>callOp</code>.  <a href="#a8e21858574e633315d8988d5ebcf46f5">More...</a><br /></td></tr>
<tr class="separator:a8e21858574e633315d8988d5ebcf46f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb96ef9c328b053a8e7c9715576d0d0"><td class="memItemLeft" align="right" valign="top">static ReturnOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#a8eb96ef9c328b053a8e7c9715576d0d0">getAssumedUniqueReturnOp</a> (FuncOp funcOp)</td></tr>
<tr class="memdesc:a8eb96ef9c328b053a8e7c9715576d0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unique ReturnOp that terminates <code>funcOp</code>.  <a href="#a8eb96ef9c328b053a8e7c9715576d0d0">More...</a><br /></td></tr>
<tr class="separator:a8eb96ef9c328b053a8e7c9715576d0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1109d802a5aa2a34cf74919ab5fc16e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#aa1109d802a5aa2a34cf74919ab5fc16e">setInPlaceOpResult</a> (<a class="el" href="classmlir_1_1OpResult.html">OpResult</a> opResult, bool inPlace)</td></tr>
<tr class="memdesc:aa1109d802a5aa2a34cf74919ab5fc16e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark whether OpResult can actually be bufferized inplace.  <a href="#aa1109d802a5aa2a34cf74919ab5fc16e">More...</a><br /></td></tr>
<tr class="separator:aa1109d802a5aa2a34cf74919ab5fc16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c2ce593ad805a35baa8c265938c01c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#a11c2ce593ad805a35baa8c265938c01c">setInPlaceFuncArgument</a> (<a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> bbArg, bool inPlace)</td></tr>
<tr class="memdesc:a11c2ce593ad805a35baa8c265938c01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the attribute that triggers inplace bufferization on a FuncOp argument <code>bbArg</code>.  <a href="#a11c2ce593ad805a35baa8c265938c01c">More...</a><br /></td></tr>
<tr class="separator:a11c2ce593ad805a35baa8c265938c01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7ec3aad9a13c917e7cd1b32be02673"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#adb7ec3aad9a13c917e7cd1b32be02673">removeBufferizationFuncArguments</a> (<a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> bbArg)</td></tr>
<tr class="memdesc:adb7ec3aad9a13c917e7cd1b32be02673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the attribute that triggers inplace bufferization on a FuncOp argument <code>bbArg</code>.  <a href="#adb7ec3aad9a13c917e7cd1b32be02673">More...</a><br /></td></tr>
<tr class="separator:adb7ec3aad9a13c917e7cd1b32be02673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141e0eb8c47839d63c212e47a42036dd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#a141e0eb8c47839d63c212e47a42036dd">printTensorOrBufferInfo</a> (std::string prefix, <a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, <a class="el" href="classmlir_1_1AsmState.html">AsmState</a> &amp;state, llvm::raw_ostream &amp;os)</td></tr>
<tr class="memdesc:a141e0eb8c47839d63c212e47a42036dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method printing the bufferization information of a buffer / tensor.  <a href="#a141e0eb8c47839d63c212e47a42036dd">More...</a><br /></td></tr>
<tr class="separator:a141e0eb8c47839d63c212e47a42036dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633548b044e2cb4d3f963b149676e667"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#a633548b044e2cb4d3f963b149676e667">areEquivalentExtractSliceOps</a> (const BufferizationAliasInfo &amp;aliasInfo, ExtractSliceOp st, InsertSliceOp sti)</td></tr>
<tr class="memdesc:a633548b044e2cb4d3f963b149676e667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the (ExtractSliceOp, InsertSliceOp) pair match (i.e.  <a href="#a633548b044e2cb4d3f963b149676e667">More...</a><br /></td></tr>
<tr class="separator:a633548b044e2cb4d3f963b149676e667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d759a8c6c40b0736e6c57c07b377805"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#a6d759a8c6c40b0736e6c57c07b377805">isInplaceMemoryWrite</a> (<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;opOperand, const BufferizationAliasInfo &amp;aliasInfo)</td></tr>
<tr class="memdesc:a6d759a8c6c40b0736e6c57c07b377805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if opOperand has been decided to bufferize in-place.  <a href="#a6d759a8c6c40b0736e6c57c07b377805">More...</a><br /></td></tr>
<tr class="separator:a6d759a8c6c40b0736e6c57c07b377805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfe57020818d03c3f833b21c3e7385f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#adcfe57020818d03c3f833b21c3e7385f">aliasesNonWritableBuffer</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, const BufferizationAliasInfo &amp;aliasInfo)</td></tr>
<tr class="memdesc:adcfe57020818d03c3f833b21c3e7385f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if, under current bufferization decisions, the buffer of <code>value</code> is not writable.  <a href="#adcfe57020818d03c3f833b21c3e7385f">More...</a><br /></td></tr>
<tr class="separator:adcfe57020818d03c3f833b21c3e7385f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9ab4e1821cf458426441c13cb2a805"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#a8f9ab4e1821cf458426441c13cb2a805">aliasesInPlaceWrite</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, const BufferizationAliasInfo &amp;aliasInfo)</td></tr>
<tr class="memdesc:a8f9ab4e1821cf458426441c13cb2a805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the buffer to which <code>operand</code> would bufferize is equivalent to some buffer write.  <a href="#a8f9ab4e1821cf458426441c13cb2a805">More...</a><br /></td></tr>
<tr class="separator:a8f9ab4e1821cf458426441c13cb2a805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6eadad09fb96d71e21048100a61fce7"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#ae6eadad09fb96d71e21048100a61fce7">hasMatchingExtractSliceOp</a> (const BufferizationAliasInfo &amp;aliasInfo, <a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, InsertSliceOp insertOp)</td></tr>
<tr class="memdesc:ae6eadad09fb96d71e21048100a61fce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <code>value</code> is originating from an ExtractSliceOp that matches the given InsertSliceOp.  <a href="#ae6eadad09fb96d71e21048100a61fce7">More...</a><br /></td></tr>
<tr class="separator:ae6eadad09fb96d71e21048100a61fce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab55113efa4ab370f96475cb0704060c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#aab55113efa4ab370f96475cb0704060c">happensBefore</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *a, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *b, const <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;domInfo)</td></tr>
<tr class="memdesc:aab55113efa4ab370f96475cb0704060c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <code>a</code> happens before <code>b</code>, i.e., <code>a</code> or one of its ancestors properly dominates <code>b</code> and <code>b</code> is not inside <code>a</code>.  <a href="#aab55113efa4ab370f96475cb0704060c">More...</a><br /></td></tr>
<tr class="separator:aab55113efa4ab370f96475cb0704060c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6479fb8e380d763b6e27bd6445f2f85"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#ad6479fb8e380d763b6e27bd6445f2f85">hasReadAfterWriteInterference</a> (const <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *&gt; &amp;usesRead, const <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *&gt; &amp;usesWrite, const <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;domInfo, const BufferizationAliasInfo &amp;aliasInfo)</td></tr>
<tr class="memdesc:ad6479fb8e380d763b6e27bd6445f2f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given sets of uses and writes, return true if there is a RaW conflict under the assumption that all given reads/writes alias the same buffer and that all given writes bufferize inplace.  <a href="#ad6479fb8e380d763b6e27bd6445f2f85">More...</a><br /></td></tr>
<tr class="separator:ad6479fb8e380d763b6e27bd6445f2f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ee262184fc2f887d47e1f244dbf965"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#a67ee262184fc2f887d47e1f244dbf965">wouldCreateReadAfterWriteInterference</a> (<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;operand, <a class="el" href="classmlir_1_1OpResult.html">OpResult</a> result, const <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;domInfo, const BufferizationAliasInfo &amp;aliasInfo, bool checkConsistencyOnly=false)</td></tr>
<tr class="memdesc:a67ee262184fc2f887d47e1f244dbf965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if bufferizing result inplace would create a conflict.  <a href="#a67ee262184fc2f887d47e1f244dbf965">More...</a><br /></td></tr>
<tr class="separator:a67ee262184fc2f887d47e1f244dbf965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8b7f82fa1f60734f2f366239036a80"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#acd8b7f82fa1f60734f2f366239036a80">wouldCreateWriteToNonWritableBuffer</a> (<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;opOperand, <a class="el" href="classmlir_1_1OpResult.html">OpResult</a> opResult, const BufferizationAliasInfo &amp;aliasInfo)</td></tr>
<tr class="memdesc:acd8b7f82fa1f60734f2f366239036a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if bufferizing <code>opOperand</code> inplace with <code>opResult</code> would create a write to a non-writable buffer.  <a href="#acd8b7f82fa1f60734f2f366239036a80">More...</a><br /></td></tr>
<tr class="separator:acd8b7f82fa1f60734f2f366239036a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa854c8b44aefa0e3175355aca7f22ed8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#aa854c8b44aefa0e3175355aca7f22ed8">getEquivalentAlloc</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, const BufferizationAliasInfo &amp;aliasInfo)</td></tr>
<tr class="memdesc:aa854c8b44aefa0e3175355aca7f22ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the op with Allocate MemoryEffect if <code>v</code> is equivalent to an such an op.  <a href="#aa854c8b44aefa0e3175355aca7f22ed8">More...</a><br /></td></tr>
<tr class="separator:aa854c8b44aefa0e3175355aca7f22ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0cde654a572bde89ba0fe1e23cc287f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#af0cde654a572bde89ba0fe1e23cc287f">getEquivalentEnclosingFuncBBArg</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> v, const BufferizationAliasInfo &amp;aliasInfo)</td></tr>
<tr class="memdesc:af0cde654a572bde89ba0fe1e23cc287f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument of the enclosing FuncOp that is equivalent to <code>v</code>.  <a href="#af0cde654a572bde89ba0fe1e23cc287f">More...</a><br /></td></tr>
<tr class="separator:af0cde654a572bde89ba0fe1e23cc287f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b622f717e73d0b52c9e763fbb0a926e"><td class="memItemLeft" align="right" valign="top">static MemRefType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#a6b622f717e73d0b52c9e763fbb0a926e">getContiguousMemRefType</a> (<a class="el" href="classmlir_1_1ShapedType.html">ShapedType</a> shapedType, MemRefLayoutAttrInterface layout={}, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace={})</td></tr>
<tr class="memdesc:a6b622f717e73d0b52c9e763fbb0a926e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a contiguous MemRefType (i.e.  <a href="#a6b622f717e73d0b52c9e763fbb0a926e">More...</a><br /></td></tr>
<tr class="separator:a6b622f717e73d0b52c9e763fbb0a926e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234ba9d71c6742551fcb99c071ef35e0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#a234ba9d71c6742551fcb99c071ef35e0">getContiguousOrUnrankedMemRefType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, MemRefLayoutAttrInterface layout={}, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace={})</td></tr>
<tr class="memdesc:a234ba9d71c6742551fcb99c071ef35e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a contiguous MemRefType (i.e.  <a href="#a234ba9d71c6742551fcb99c071ef35e0">More...</a><br /></td></tr>
<tr class="separator:a234ba9d71c6742551fcb99c071ef35e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7d30e1002b1c38f48808d53fb53103"><td class="memItemLeft" align="right" valign="top">static MemRefType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#abb7d30e1002b1c38f48808d53fb53103">getDynamicMemRefType</a> (RankedTensorType tensorType, <a class="el" href="classunsigned.html">unsigned</a> addressSpace=0)</td></tr>
<tr class="memdesc:abb7d30e1002b1c38f48808d53fb53103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a MemRefType to which the <code>tensorType</code> can be bufferized in a composable fashion.  <a href="#abb7d30e1002b1c38f48808d53fb53103">More...</a><br /></td></tr>
<tr class="separator:abb7d30e1002b1c38f48808d53fb53103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aaa023f29fb72bbb4ebb178423578e5"><td class="memItemLeft" align="right" valign="top">static FunctionType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#a6aaa023f29fb72bbb4ebb178423578e5">getBufferizedFunctionType</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> argumentTypes, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> resultTypes)</td></tr>
<tr class="memdesc:a6aaa023f29fb72bbb4ebb178423578e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the FunctionType with <code>argumentTypes</code> and <code>resultTypes</code> where each tensor is replaced by the corresponding buffer type.  <a href="#a6aaa023f29fb72bbb4ebb178423578e5">More...</a><br /></td></tr>
<tr class="separator:a6aaa023f29fb72bbb4ebb178423578e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc199860e7feb8dd45b81ea38cc3738"><td class="memItemLeft" align="right" valign="top">static FunctionType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#a0dc199860e7feb8dd45b81ea38cc3738">getOrCreateBufferizedFunctionType</a> (FuncOp funcOp, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> argumentTypes, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> resultTypes, <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; FuncOp, FunctionType &gt; &amp;bufferizedFunctionTypes)</td></tr>
<tr class="memdesc:a0dc199860e7feb8dd45b81ea38cc3738"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an entry for <code>funcOp</code> is available in <code>bufferizedFunctionTypes</code>, return it.  <a href="#a0dc199860e7feb8dd45b81ea38cc3738">More...</a><br /></td></tr>
<tr class="separator:a0dc199860e7feb8dd45b81ea38cc3738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafb910b9297e1def2d183b2ff15d7bd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#afafb910b9297e1def2d183b2ff15d7bd">moveInsertionPointToAllocationHoistingBarrier</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b)</td></tr>
<tr class="memdesc:afafb910b9297e1def2d183b2ff15d7bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the insertion point of the given builder to the beginning of a surrounding block as much as possible, while not crossing any allocation hoisting barriers.  <a href="#afafb910b9297e1def2d183b2ff15d7bd">More...</a><br /></td></tr>
<tr class="separator:afafb910b9297e1def2d183b2ff15d7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a28330a3824749a13699ca484dcd4f"><td class="memItemLeft" align="right" valign="top">static MemRefType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#a78a28330a3824749a13699ca484dcd4f">getAllocationTypeAndShape</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> shapedValue, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;dynShape)</td></tr>
<tr class="memdesc:a78a28330a3824749a13699ca484dcd4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the type of the <code>memref</code> to use for allocating the buffer for <code>shapedValue</code>.  <a href="#a78a28330a3824749a13699ca484dcd4f">More...</a><br /></td></tr>
<tr class="separator:a78a28330a3824749a13699ca484dcd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d73f35d709da63727f4c70f155ea74"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#ac5d73f35d709da63727f4c70f155ea74">createNewAllocDeallocPairForShapedValue</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> shapedValue, BufferizationState &amp;state)</td></tr>
<tr class="memdesc:ac5d73f35d709da63727f4c70f155ea74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an Allocop/DeAllocOp pair, where the AllocOp is after <code>shapedValue.getDefiningOp</code> (or at the top of the block in case of a bbArg) and the DeallocOp is at the end of the block.  <a href="#ac5d73f35d709da63727f4c70f155ea74">More...</a><br /></td></tr>
<tr class="separator:ac5d73f35d709da63727f4c70f155ea74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf71d9c412f48c914f4160a8a0faa1df"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#adf71d9c412f48c914f4160a8a0faa1df">bufferize</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, CallOpInterface callOp, BufferizationState &amp;state, <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; FuncOp, FunctionType &gt; &amp;bufferizedFunctionTypes)</td></tr>
<tr class="memdesc:adf71d9c412f48c914f4160a8a0faa1df"><td class="mdescLeft">&#160;</td><td class="mdescRight">In a first approximation, all the function arguments of a FuncOp are marked inplaceable.  <a href="#adf71d9c412f48c914f4160a8a0faa1df">More...</a><br /></td></tr>
<tr class="separator:adf71d9c412f48c914f4160a8a0faa1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a5940d2aef65c5064fd6609fa9ec7b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#ad7a5940d2aef65c5064fd6609fa9ec7b">bufferize</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, FuncOp funcOp, BufferizationState &amp;state)</td></tr>
<tr class="memdesc:ad7a5940d2aef65c5064fd6609fa9ec7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">FuncOp always creates TensorToMemRef ops.  <a href="#ad7a5940d2aef65c5064fd6609fa9ec7b">More...</a><br /></td></tr>
<tr class="separator:ad7a5940d2aef65c5064fd6609fa9ec7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe30d25b333ec15353d236d5adcb3bcf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#abe30d25b333ec15353d236d5adcb3bcf">bufferizableInPlaceAnalysisImpl</a> (<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;operand, <a class="el" href="classmlir_1_1OpResult.html">OpResult</a> result, BufferizationAliasInfo &amp;aliasInfo, const <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;domInfo)</td></tr>
<tr class="memdesc:abe30d25b333ec15353d236d5adcb3bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if <code>operand</code> can be bufferized in-place with <code>result</code>.  <a href="#abe30d25b333ec15353d236d5adcb3bcf">More...</a><br /></td></tr>
<tr class="separator:abe30d25b333ec15353d236d5adcb3bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c63b6b34c37533b6398893ee8e12e74"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#a1c63b6b34c37533b6398893ee8e12e74">bufferizableInPlaceAnalysis</a> (<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;operand, BufferizationAliasInfo &amp;aliasInfo, const <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;domInfo)</td></tr>
<tr class="memdesc:a1c63b6b34c37533b6398893ee8e12e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if <code>operand</code> can be bufferized in-place with one of the op's results.  <a href="#a1c63b6b34c37533b6398893ee8e12e74">More...</a><br /></td></tr>
<tr class="separator:a1c63b6b34c37533b6398893ee8e12e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0389e3ab6c3f6d8ed10a1ffd389b73df"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#a0389e3ab6c3f6d8ed10a1ffd389b73df">inPlaceAnalysisFuncOpBody</a> (FuncOp funcOp, BufferizationAliasInfo &amp;aliasInfo, const <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;domInfo, <a class="el" href="classunsigned.html">unsigned</a> analysisFuzzerSeed=0)</td></tr>
<tr class="memdesc:a0389e3ab6c3f6d8ed10a1ffd389b73df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze the <code>funcOp</code> body to determine which OpResults are inplaceable.  <a href="#a0389e3ab6c3f6d8ed10a1ffd389b73df">More...</a><br /></td></tr>
<tr class="separator:a0389e3ab6c3f6d8ed10a1ffd389b73df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5572b70d5043eb03af144a7fc79c64"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#a2c5572b70d5043eb03af144a7fc79c64">bufferizeFuncOpInternals</a> (FuncOp funcOp, BufferizationState &amp;state, <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; FuncOp, FunctionType &gt; &amp;bufferizedFunctionTypes)</td></tr>
<tr class="separator:a2c5572b70d5043eb03af144a7fc79c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f10dcb56ecdfe098224a8100478fe37"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#a6f10dcb56ecdfe098224a8100478fe37">bufferizeFuncOpBoundary</a> (FuncOp funcOp, BufferizationAliasInfo &amp;aliasInfo, <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; FuncOp, FunctionType &gt; &amp;bufferizedFunctionTypes)</td></tr>
<tr class="memdesc:a6f10dcb56ecdfe098224a8100478fe37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the <code>funcOp</code> arguments analysis return values and terminator into buffer form (using the canonical memref layout for now), according to the inPlace-bufferizable information of the function arguments.  <a href="#a6f10dcb56ecdfe098224a8100478fe37">More...</a><br /></td></tr>
<tr class="separator:a6f10dcb56ecdfe098224a8100478fe37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936fdd29984c48c5448adc48709ec395"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#a936fdd29984c48c5448adc48709ec395">getFuncOpsOrderedByCalls</a> (ModuleOp moduleOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; FuncOp &gt; &amp;orderedFuncOps, <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; FuncOp, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&gt; &amp;callerMap)</td></tr>
<tr class="memdesc:a936fdd29984c48c5448adc48709ec395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store all functions of the <code>moduleOp</code> in <code>orderedFuncOps</code>, sorted by callee-caller order (i.e.  <a href="#a936fdd29984c48c5448adc48709ec395">More...</a><br /></td></tr>
<tr class="separator:a936fdd29984c48c5448adc48709ec395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad001b34103c1d4ace7b47aaf5ea5346f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#ad001b34103c1d4ace7b47aaf5ea5346f">foreachCaller</a> (const <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; FuncOp, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&gt; &amp;callerMap, FuncOp callee, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; doit)</td></tr>
<tr class="separator:ad001b34103c1d4ace7b47aaf5ea5346f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e4e097aa4d933636c66131e3955068"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#a91e4e097aa4d933636c66131e3955068">layoutPostProcessing</a> (ModuleOp moduleOp)</td></tr>
<tr class="memdesc:a91e4e097aa4d933636c66131e3955068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postprocess the linalg.buffer_layout annotation across function boundaries.  <a href="#a91e4e097aa4d933636c66131e3955068">More...</a><br /></td></tr>
<tr class="separator:a91e4e097aa4d933636c66131e3955068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae863591306c8a79350821bff53a7a417"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#ae863591306c8a79350821bff53a7a417">checkAliasInfoConsistency</a> (FuncOp funcOp, const <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;domInfo, const BufferizationAliasInfo &amp;aliasInfo)</td></tr>
<tr class="memdesc:ae863591306c8a79350821bff53a7a417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert that the current bufferization decisions are consistent.  <a href="#ae863591306c8a79350821bff53a7a417">More...</a><br /></td></tr>
<tr class="separator:ae863591306c8a79350821bff53a7a417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d606bb66e46930b4aff570abe80e53"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#ad9d606bb66e46930b4aff570abe80e53">annotateOpsWithBufferizationMarkers</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const BufferizationAliasInfo &amp;aliasInfo)</td></tr>
<tr class="memdesc:ad9d606bb66e46930b4aff570abe80e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotate the IR with the result of the analysis. For testing/debugging only.  <a href="#ad9d606bb66e46930b4aff570abe80e53">More...</a><br /></td></tr>
<tr class="separator:ad9d606bb66e46930b4aff570abe80e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e26c9a5a516b839faa45c7c2cf041b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg_1_1comprehensive__bufferize_1_1scf__ext.html#ae9e26c9a5a516b839faa45c7c2cf041b">mlir::linalg::comprehensive_bufferize::scf_ext::bufferizeIfOp</a> (scf::IfOp ifOp, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, BufferizationState &amp;state)</td></tr>
<tr class="memdesc:ae9e26c9a5a516b839faa45c7c2cf041b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferize the scf::IfOp.  <a href="namespacemlir_1_1linalg_1_1comprehensive__bufferize_1_1scf__ext.html#ae9e26c9a5a516b839faa45c7c2cf041b">More...</a><br /></td></tr>
<tr class="separator:ae9e26c9a5a516b839faa45c7c2cf041b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e5f38521d3796a7f70f3a547e05a59"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg_1_1comprehensive__bufferize_1_1scf__ext.html#ae5e5f38521d3796a7f70f3a547e05a59">mlir::linalg::comprehensive_bufferize::scf_ext::bufferizeForOp</a> (scf::ForOp forOp, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, BufferizationState &amp;state)</td></tr>
<tr class="memdesc:ae5e5f38521d3796a7f70f3a547e05a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferize the scf::ForOp.  <a href="namespacemlir_1_1linalg_1_1comprehensive__bufferize_1_1scf__ext.html#ae5e5f38521d3796a7f70f3a547e05a59">More...</a><br /></td></tr>
<tr class="separator:ae5e5f38521d3796a7f70f3a547e05a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c00a01c100283d3b6c84fedace8a860"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg_1_1comprehensive__bufferize_1_1tensor__ext.html#a5c00a01c100283d3b6c84fedace8a860">mlir::linalg::comprehensive_bufferize::tensor_ext::isSourceEquivalentToAMatchingInplaceExtractSliceOp</a> (const BufferizationAliasInfo &amp;aliasInfo, InsertSliceOp insertSliceOp)</td></tr>
<tr class="memdesc:a5c00a01c100283d3b6c84fedace8a860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the source of a <code>insertSliceOp</code> bufferizes to an equivalent ExtractSliceOp that bufferizes inplace.  <a href="namespacemlir_1_1linalg_1_1comprehensive__bufferize_1_1tensor__ext.html#a5c00a01c100283d3b6c84fedace8a860">More...</a><br /></td></tr>
<tr class="separator:a5c00a01c100283d3b6c84fedace8a860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78da92a1ab62c853381b29fea53d0928"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg_1_1comprehensive__bufferize.html#a78da92a1ab62c853381b29fea53d0928">mlir::linalg::comprehensive_bufferize::registerBufferizableOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a78da92a1ab62c853381b29fea53d0928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register external models implemented for the <code>BufferizableOpInterface</code>.  <a href="namespacemlir_1_1linalg_1_1comprehensive__bufferize.html#a78da92a1ab62c853381b29fea53d0928">More...</a><br /></td></tr>
<tr class="separator:a78da92a1ab62c853381b29fea53d0928"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a660646289e735830b2490d50e78de988"><td class="memItemLeft" align="right" valign="top">constexpr StringLiteral&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ComprehensiveBufferize_8cpp.html#a660646289e735830b2490d50e78de988">kInPlaceResultsAttrName</a> = &quot;__inplace_results_attr__&quot;</td></tr>
<tr class="memdesc:a660646289e735830b2490d50e78de988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute marker to specify op results that can be bufferized inPlace.  <a href="#a660646289e735830b2490d50e78de988">More...</a><br /></td></tr>
<tr class="separator:a660646289e735830b2490d50e78de988"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ae0bb487c37194ac844a13205a7edcefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0bb487c37194ac844a13205a7edcefc">&#9670;&nbsp;</a></span>DBGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DBGS</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(llvm::dbgs() &lt;&lt; '[' &lt;&lt; <a class="el" href="Transforms_2Utils_2Utils_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a> &lt;&lt; &quot;] &quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00139">139</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01311">bufferizeFuncOpBoundary()</a>.</p>

</div>
</div>
<a id="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&nbsp;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;comprehensive-module-<a class="el" href="ComprehensiveBufferize_8cpp.html#ad7a5940d2aef65c5064fd6609fa9ec7b">bufferize</a>&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00132">132</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00245">printOperationInfo()</a>.</p>

</div>
</div>
<a id="aebb7bbd2151d1599f0a2a4dd7be89253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb7bbd2151d1599f0a2a4dd7be89253">&#9670;&nbsp;</a></span>LDBG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LDBG</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">X</td><td>)</td>
          <td>&#160;&#160;&#160;LLVM_DEBUG(<a class="el" href="VectorTransferOpTransforms_8cpp.html#ae0bb487c37194ac844a13205a7edcefc">DBGS</a>() &lt;&lt; X)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00140">140</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00349">aliasesInPlaceWrite()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00314">aliasesNonWritableBuffer()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01039">bufferizableInPlaceAnalysisImpl()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l02244">mlir::linalg::comprehensive_bufferize::tensor_ext::ExtractSliceOpInterface::bufferize()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l02374">mlir::linalg::comprehensive_bufferize::tensor_ext::InsertSliceOpInterface::bufferize()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01214">bufferizeFuncOpInternals()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01184">mlir::linalg::comprehensive_bufferize::bufferizeOp()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00741">getOrCreateBufferizedFunctionType()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00409">hasReadAfterWriteInterference()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01126">inPlaceAnalysisFuncOpBody()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l02326">mlir::linalg::comprehensive_bufferize::tensor_ext::isSourceEquivalentToAMatchingInplaceExtractSliceOp()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00192">setInPlaceOpResult()</a>, and <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00628">wouldCreateWriteToNonWritableBuffer()</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8f9ab4e1821cf458426441c13cb2a805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9ab4e1821cf458426441c13cb2a805">&#9670;&nbsp;</a></span>aliasesInPlaceWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool aliasesInPlaceWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BufferizationAliasInfo &amp;&#160;</td>
          <td class="paramname"><em>aliasInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the buffer to which <code>operand</code> would bufferize is equivalent to some buffer write. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00349">349</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00198">mlir::Value::getUses()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00303">isInplaceMemoryWrite()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00140">LDBG</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00245">printOperationInfo()</a>, and <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00266">printValueInfo()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00628">wouldCreateWriteToNonWritableBuffer()</a>.</p>

</div>
</div>
<a id="adcfe57020818d03c3f833b21c3e7385f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcfe57020818d03c3f833b21c3e7385f">&#9670;&nbsp;</a></span>aliasesNonWritableBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool aliasesNonWritableBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BufferizationAliasInfo &amp;&#160;</td>
          <td class="paramname"><em>aliasInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if, under current bufferization decisions, the buffer of <code>value</code> is not writable. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00314">314</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00101">mlir::Value::dyn_cast()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00140">LDBG</a>, and <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00266">printValueInfo()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00628">wouldCreateWriteToNonWritableBuffer()</a>.</p>

</div>
</div>
<a id="ad9d606bb66e46930b4aff570abe80e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d606bb66e46930b4aff570abe80e53">&#9670;&nbsp;</a></span>annotateOpsWithBufferizationMarkers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> annotateOpsWithBufferizationMarkers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BufferizationAliasInfo &amp;&#160;</td>
          <td class="paramname"><em>aliasInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Annotate the IR with the result of the analysis. For testing/debugging only. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01613">1613</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Operation_8h_source.html#l00284">mlir::Operation::getResults()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00212">setInPlaceFuncArgument()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00192">setInPlaceOpResult()</a>, and <a class="el" href="Operation_8h_source.html#l00515">mlir::Operation::walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01628">mlir::linalg::comprehensive_bufferize::runComprehensiveBufferize()</a>.</p>

</div>
</div>
<a id="a633548b044e2cb4d3f963b149676e667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a633548b044e2cb4d3f963b149676e667">&#9670;&nbsp;</a></span>areEquivalentExtractSliceOps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool areEquivalentExtractSliceOps </td>
          <td>(</td>
          <td class="paramtype">const BufferizationAliasInfo &amp;&#160;</td>
          <td class="paramname"><em>aliasInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExtractSliceOp&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InsertSliceOp&#160;</td>
          <td class="paramname"><em>sti</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the (ExtractSliceOp, InsertSliceOp) pair match (i.e. </p>
<p>equivalent operand / result and same offset/sizes/strides specification).</p>
<p>This is one particular type of relationship between ops on tensors that reduce to an equivalence on buffers. This should be generalized and exposed as interfaces on the proper types. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00291">291</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00086">mlir::isEqualConstantIntOrValue()</a>, and <a class="el" href="Hoisting_8cpp_source.html#l00077">sameOffsetsSizesAndStrides()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00373">hasMatchingExtractSliceOp()</a>, and <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l02326">mlir::linalg::comprehensive_bufferize::tensor_ext::isSourceEquivalentToAMatchingInplaceExtractSliceOp()</a>.</p>

</div>
</div>
<a id="a1c63b6b34c37533b6398893ee8e12e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c63b6b34c37533b6398893ee8e12e74">&#9670;&nbsp;</a></span>bufferizableInPlaceAnalysis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> bufferizableInPlaceAnalysis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BufferizationAliasInfo &amp;&#160;</td>
          <td class="paramname"><em>aliasInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>domInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if <code>operand</code> can be bufferized in-place with one of the op's results. </p>
<p>Even if an op does not read or write, it may still create an alias when bufferized in-place. An example of such ops is tensor.extract_slice.</p>
<p>Rationale for bufferizing <code>%1 = tensor.extract_slice %0[...]</code> inplace:</p>
<p>When bufferized out of place, an ExtractSliceOp lowers to alloc + copy. This cannot change the flow of information for either the source or the result buffers.</p>
<p>When bufferized inplace, an ExtractSliceOp does not by itself create any read or write from memory. Instead, it has the effect of merging the alias sets of the source and the result buffers.</p>
<p>An analysis is required to ensure inplace bufferization would not result in RaW dependence violations. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01089">1089</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01039">bufferizableInPlaceAnalysisImpl()</a>, <a class="el" href="UseDefLists_8h_source.html#l00037">mlir::detail::IROperandBase::getOwner()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01103">mlir::linalg::comprehensive_bufferize::inPlaceAnalysis()</a>.</p>

</div>
</div>
<a id="abe30d25b333ec15353d236d5adcb3bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe30d25b333ec15353d236d5adcb3bcf">&#9670;&nbsp;</a></span>bufferizableInPlaceAnalysisImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> bufferizableInPlaceAnalysisImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a>&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BufferizationAliasInfo &amp;&#160;</td>
          <td class="paramname"><em>aliasInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>domInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if <code>operand</code> can be bufferized in-place with <code>result</code>. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01039">1039</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00178">mlir::linalg::comprehensive_bufferize::getAliasingOpOperand()</a>, <a class="el" href="Value_8cpp_source.html#l00212">mlir::OpOperand::getOperandNumber()</a>, <a class="el" href="Value_8h_source.html#l00437">mlir::OpResult::getResultNumber()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00140">LDBG</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00266">printValueInfo()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00583">wouldCreateReadAfterWriteInterference()</a>, and <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00628">wouldCreateWriteToNonWritableBuffer()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01089">bufferizableInPlaceAnalysis()</a>.</p>

</div>
</div>
<a id="adf71d9c412f48c914f4160a8a0faa1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf71d9c412f48c914f4160a8a0faa1df">&#9670;&nbsp;</a></span>bufferize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> bufferize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallOpInterface&#160;</td>
          <td class="paramname"><em>callOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BufferizationState &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; FuncOp, FunctionType &gt; &amp;&#160;</td>
          <td class="paramname"><em>bufferizedFunctionTypes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In a first approximation, all the function arguments of a FuncOp are marked inplaceable. </p>
<p>For now, it is the responsibility of the <code>callOp</code> bufferization to allow FuncOp that are inplaceable to write inPlace. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00875">875</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00424">mlir::OpBuilder::create()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00165">getAssumedUniqueReturnOp()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00155">getCalledFunction()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01261">getEquivalentAlloc()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01278">getEquivalentEnclosingFuncBBArg()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00741">getOrCreateBufferizedFunctionType()</a>, <a class="el" href="Value_8h_source.html#l00119">mlir::Value::getType()</a>, <a class="el" href="Types_8h_source.html#l00234">mlir::Type::isa()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00152">isaTensor()</a>, <a class="el" href="Value_8h_source.html#l00163">mlir::Value::replaceAllUsesWith()</a>, <a class="el" href="Operation_8h_source.html#l00314">mlir::Operation::setAttrs()</a>, <a class="el" href="Builders_8h_source.html#l00331">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01214">bufferizeFuncOpInternals()</a>, and <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01184">mlir::linalg::comprehensive_bufferize::bufferizeOp()</a>.</p>

</div>
</div>
<a id="ad7a5940d2aef65c5064fd6609fa9ec7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a5940d2aef65c5064fd6609fa9ec7b">&#9670;&nbsp;</a></span>bufferize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> bufferize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncOp&#160;</td>
          <td class="paramname"><em>funcOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BufferizationState &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>FuncOp always creates TensorToMemRef ops. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01010">1010</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00424">mlir::OpBuilder::create()</a>, <a class="el" href="Types_8h_source.html#l00244">mlir::Type::dyn_cast()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00689">getContiguousOrUnrankedMemRefType()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00702">getDynamicMemRefType()</a>, <a class="el" href="Builders_8h_source.html#l00364">mlir::OpBuilder::setInsertionPointToStart()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="a6f10dcb56ecdfe098224a8100478fe37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f10dcb56ecdfe098224a8100478fe37">&#9670;&nbsp;</a></span>bufferizeFuncOpBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> bufferizeFuncOpBoundary </td>
          <td>(</td>
          <td class="paramtype">FuncOp&#160;</td>
          <td class="paramname"><em>funcOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BufferizationAliasInfo &amp;&#160;</td>
          <td class="paramname"><em>aliasInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; FuncOp, FunctionType &gt; &amp;&#160;</td>
          <td class="paramname"><em>bufferizedFunctionTypes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rewrite the <code>funcOp</code> arguments analysis return values and terminator into buffer form (using the canonical memref layout for now), according to the inPlace-bufferizable information of the function arguments. </p>
<p>This relies on a buffer equivalence analysis of each return operand. When a result buffer is equivalent to:</p><ol type="1">
<li>a BlockArgument of <code>funcOp</code>, it can be dropped from the return values and becomes inplaceable at all callers. This assumes all CallOp perform the necessary work to clone operands so as to make them inplaceable. 2. an op with an Alloc effect, this currently fails bufferization but is a candidate for hoisting and creating a new inplace operand at all caller sites.</li>
</ol>
<p>if such a hoisting for 2. is not possible (e.g. data-dependent that prevents hoisting), this is currently unsupported and will require a refcounted buffer type. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01311">1311</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8cpp_source.html#l00141">mlir::Block::addArgument()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00139">DBGS</a>, <a class="el" href="Types_8h_source.html#l00244">mlir::Type::dyn_cast()</a>, <a class="el" href="Block_8cpp_source.html#l00208">mlir::Block::eraseArgument()</a>, <a class="el" href="Block_8h_source.html#l00145">mlir::Block::front()</a>, <a class="el" href="Block_8h_source.html#l00121">mlir::Block::getArgument()</a>, <a class="el" href="Block_8h_source.html#l00076">mlir::Block::getArguments()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00165">getAssumedUniqueReturnOp()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01261">getEquivalentAlloc()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01278">getEquivalentEnclosingFuncBBArg()</a>, <a class="el" href="Block_8h_source.html#l00120">mlir::Block::getNumArguments()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00741">getOrCreateBufferizedFunctionType()</a>, <a class="el" href="Value_8h_source.html#l00119">mlir::Value::getType()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00152">isaTensor()</a>, <a class="el" href="Value_8h_source.html#l00163">mlir::Value::replaceAllUsesWith()</a>, <a class="el" href="Builders_8h_source.html#l00364">mlir::OpBuilder::setInsertionPointToStart()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01628">mlir::linalg::comprehensive_bufferize::runComprehensiveBufferize()</a>.</p>

</div>
</div>
<a id="a2c5572b70d5043eb03af144a7fc79c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5572b70d5043eb03af144a7fc79c64">&#9670;&nbsp;</a></span>bufferizeFuncOpInternals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> bufferizeFuncOpInternals </td>
          <td>(</td>
          <td class="paramtype">FuncOp&#160;</td>
          <td class="paramname"><em>funcOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BufferizationState &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; FuncOp, FunctionType &gt; &amp;&#160;</td>
          <td class="paramname"><em>bufferizedFunctionTypes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01214">1214</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00875">bufferize()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01184">mlir::linalg::comprehensive_bufferize::bufferizeOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00152">isaTensor()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00140">LDBG</a>, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca622a0c108b4c33e1cc5ed8a22db11cbc">mlir::PreOrder</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01628">mlir::linalg::comprehensive_bufferize::runComprehensiveBufferize()</a>.</p>

</div>
</div>
<a id="ae863591306c8a79350821bff53a7a417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae863591306c8a79350821bff53a7a417">&#9670;&nbsp;</a></span>checkAliasInfoConsistency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> checkAliasInfoConsistency </td>
          <td>(</td>
          <td class="paramtype">FuncOp&#160;</td>
          <td class="paramname"><em>funcOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>domInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BufferizationAliasInfo &amp;&#160;</td>
          <td class="paramname"><em>aliasInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assert that the current bufferization decisions are consistent. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01593">1593</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Operation_8h_source.html#l00252">mlir::Operation::getOpOperands()</a>, and <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00583">wouldCreateReadAfterWriteInterference()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01628">mlir::linalg::comprehensive_bufferize::runComprehensiveBufferize()</a>.</p>

</div>
</div>
<a id="ac5d73f35d709da63727f4c70f155ea74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d73f35d709da63727f4c70f155ea74">&#9670;&nbsp;</a></span>createNewAllocDeallocPairForShapedValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Value.html">Value</a> createNewAllocDeallocPairForShapedValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>shapedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BufferizationState &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an Allocop/DeAllocOp pair, where the AllocOp is after <code>shapedValue.getDefiningOp</code> (or at the top of the block in case of a bbArg) and the DeallocOp is at the end of the block. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00838">838</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00424">mlir::OpBuilder::create()</a>, <a class="el" href="Types_8h_source.html#l00244">mlir::Type::dyn_cast()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00791">getAllocationTypeAndShape()</a>, <a class="el" href="Value_8h_source.html#l00119">mlir::Value::getType()</a>, <a class="el" href="Types_8h_source.html#l00234">mlir::Type::isa()</a>, and <a class="el" href="Builders_8h_source.html#l00331">mlir::OpBuilder::setInsertionPoint()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l02244">mlir::linalg::comprehensive_bufferize::tensor_ext::ExtractSliceOpInterface::bufferize()</a>, and <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01728">mlir::linalg::comprehensive_bufferize::defaultAllocationCallbacks()</a>.</p>

</div>
</div>
<a id="ad001b34103c1d4ace7b47aaf5ea5346f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad001b34103c1d4ace7b47aaf5ea5346f">&#9670;&nbsp;</a></span>foreachCaller()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> foreachCaller </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; FuncOp, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>callerMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FuncOp&#160;</td>
          <td class="paramname"><em>callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;&#160;</td>
          <td class="paramname"><em>doit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01501">1501</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

</div>
</div>
<a id="a78a28330a3824749a13699ca484dcd4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a28330a3824749a13699ca484dcd4f">&#9670;&nbsp;</a></span>getAllocationTypeAndShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static MemRefType getAllocationTypeAndShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>shapedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dynShape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the type of the <code>memref</code> to use for allocating the buffer for <code>shapedValue</code>. </p>
<p>Also returns (by reference in <code>dynShape</code>), the value for the dynamic dimensions in the returned <code>memref</code> type. The function may also set the insertion point to an earlier location, where the allocation should happen ("allocation hoisting"). </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00791">791</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00250">mlir::Type::cast()</a>, <a class="el" href="Builders_8h_source.html#l00424">mlir::OpBuilder::create()</a>, <a class="el" href="Value_8h_source.html#l00101">mlir::Value::dyn_cast()</a>, <a class="el" href="Matchers_8h_source.html#l00206">mlir::detail::enumerate()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00678">getContiguousMemRefType()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8h_source.html#l00437">mlir::OpResult::getResultNumber()</a>, <a class="el" href="Value_8h_source.html#l00119">mlir::Value::getType()</a>, <a class="el" href="Types_8h_source.html#l00234">mlir::Type::isa()</a>, <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00138">mlir::ShapedType::isDynamic()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00762">moveInsertionPointToAllocationHoistingBarrier()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00068">mlir::succeeded()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00838">createNewAllocDeallocPairForShapedValue()</a>.</p>

</div>
</div>
<a id="a8eb96ef9c328b053a8e7c9715576d0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb96ef9c328b053a8e7c9715576d0d0">&#9670;&nbsp;</a></span>getAssumedUniqueReturnOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ReturnOp getAssumedUniqueReturnOp </td>
          <td>(</td>
          <td class="paramtype">FuncOp&#160;</td>
          <td class="paramname"><em>funcOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the unique ReturnOp that terminates <code>funcOp</code>. </p>
<p>Return nullptr if there is no such unique ReturnOp. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00165">165</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00875">bufferize()</a>, and <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01311">bufferizeFuncOpBoundary()</a>.</p>

</div>
</div>
<a id="a6aaa023f29fb72bbb4ebb178423578e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aaa023f29fb72bbb4ebb178423578e5">&#9670;&nbsp;</a></span>getBufferizedFunctionType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FunctionType getBufferizedFunctionType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>argumentTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>resultTypes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the FunctionType with <code>argumentTypes</code> and <code>resultTypes</code> where each tensor is replaced by the corresponding buffer type. </p>
<p>In order for all the callers to agree, this <em>must</em> bufferize to the most dynamic buffer type supported. A later pass across all CallOps in the module can decide whether to simplify the types of to version according to some cost model. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00720">720</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00689">getContiguousOrUnrankedMemRefType()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00702">getDynamicMemRefType()</a>, and <a class="el" href="SCCP_8cpp_source.html#l00189">rewrite()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00741">getOrCreateBufferizedFunctionType()</a>.</p>

</div>
</div>
<a id="a8e21858574e633315d8988d5ebcf46f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e21858574e633315d8988d5ebcf46f5">&#9670;&nbsp;</a></span>getCalledFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FuncOp getCalledFunction </td>
          <td>(</td>
          <td class="paramtype">CallOpInterface&#160;</td>
          <td class="paramname"><em>callOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the FuncOp called by <code>callOp</code>. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00155">155</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="SymbolTable_8cpp_source.html#l00370">mlir::SymbolTable::lookupNearestSymbolFrom()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00875">bufferize()</a>.</p>

</div>
</div>
<a id="a6b622f717e73d0b52c9e763fbb0a926e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b622f717e73d0b52c9e763fbb0a926e">&#9670;&nbsp;</a></span>getContiguousMemRefType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static MemRefType getContiguousMemRefType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ShapedType.html">ShapedType</a>&#160;</td>
          <td class="paramname"><em>shapedType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefLayoutAttrInterface&#160;</td>
          <td class="paramname"><em>layout</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a contiguous MemRefType (i.e. </p>
<p>with canonical/empty layout map) with the same shape as <code>shapedType</code> and specified <code>layout</code> and <code>addressSpace</code>. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00678">678</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00348">mlir::ShapedType::getElementType()</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00418">mlir::ShapedType::getShape()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00791">getAllocationTypeAndShape()</a>, and <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00689">getContiguousOrUnrankedMemRefType()</a>.</p>

</div>
</div>
<a id="a234ba9d71c6742551fcb99c071ef35e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234ba9d71c6742551fcb99c071ef35e0">&#9670;&nbsp;</a></span>getContiguousOrUnrankedMemRefType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Type.html">Type</a> getContiguousOrUnrankedMemRefType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefLayoutAttrInterface&#160;</td>
          <td class="paramname"><em>layout</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a contiguous MemRefType (i.e. </p>
<p>with canonical/empty layout map) with the same shape as <code>shapedType</code> and specified <code>layout</code> and <code>addressSpace</code> or an <a class="el" href="structUnrankedMemRefType.html">UnrankedMemRefType</a> otherwise. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00689">689</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00250">mlir::Type::cast()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00678">getContiguousMemRefType()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00024">mlir::getElementTypeOrSelf()</a>, and <a class="el" href="Types_8h_source.html#l00234">mlir::Type::isa()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01010">bufferize()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l02153">mlir::linalg::comprehensive_bufferize::tensor_ext::CastOpInterface::bufferize()</a>, and <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00720">getBufferizedFunctionType()</a>.</p>

</div>
</div>
<a id="abb7d30e1002b1c38f48808d53fb53103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7d30e1002b1c38f48808d53fb53103">&#9670;&nbsp;</a></span>getDynamicMemRefType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static MemRefType getDynamicMemRefType </td>
          <td>(</td>
          <td class="paramtype">RankedTensorType&#160;</td>
          <td class="paramname"><em>tensorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>addressSpace</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a MemRefType to which the <code>tensorType</code> can be bufferized in a composable fashion. </p>
<p>The layout must be the most dynamic possible and canonicalize away once bufferization is finished. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00702">702</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinTypes_8h_source.html#l00074">mlir::ShapedType::kDynamicStrideOrOffset</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00986">mlir::makeStridedLinearLayoutMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01010">bufferize()</a>, and <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00720">getBufferizedFunctionType()</a>.</p>

</div>
</div>
<a id="aa854c8b44aefa0e3175355aca7f22ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa854c8b44aefa0e3175355aca7f22ed8">&#9670;&nbsp;</a></span>getEquivalentAlloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> * getEquivalentAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BufferizationAliasInfo &amp;&#160;</td>
          <td class="paramname"><em>aliasInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the op with Allocate MemoryEffect if <code>v</code> is equivalent to an such an op. </p>
<p>Return the op with Allocate MemoryEffect if <code>v</code> is equivalent to such an an op.</p>
<p>Return null otherwise. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01261">1261</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00875">bufferize()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01311">bufferizeFuncOpBoundary()</a>, and <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00628">wouldCreateWriteToNonWritableBuffer()</a>.</p>

</div>
</div>
<a id="af0cde654a572bde89ba0fe1e23cc287f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0cde654a572bde89ba0fe1e23cc287f">&#9670;&nbsp;</a></span>getEquivalentEnclosingFuncBBArg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> getEquivalentEnclosingFuncBBArg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BufferizationAliasInfo &amp;&#160;</td>
          <td class="paramname"><em>aliasInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the first argument of the enclosing FuncOp that is equivalent to <code>v</code>. </p>
<p>Return null if no such bbArg can be found. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01278">1278</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00048">mlir::Value::getParentBlock()</a>, <a class="el" href="Operation_8h_source.html#l00120">mlir::Operation::getParentOfType()</a>, <a class="el" href="Block_8cpp_source.html#l00030">mlir::Block::getParentOp()</a>, <a class="el" href="Value_8h_source.html#l00119">mlir::Value::getType()</a>, and <a class="el" href="Types_8h_source.html#l00234">mlir::Type::isa()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00875">bufferize()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01311">bufferizeFuncOpBoundary()</a>, and <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00628">wouldCreateWriteToNonWritableBuffer()</a>.</p>

</div>
</div>
<a id="a936fdd29984c48c5448adc48709ec395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936fdd29984c48c5448adc48709ec395">&#9670;&nbsp;</a></span>getFuncOpsOrderedByCalls()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> getFuncOpsOrderedByCalls </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>moduleOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; FuncOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>orderedFuncOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; FuncOp, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>callerMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Store all functions of the <code>moduleOp</code> in <code>orderedFuncOps</code>, sorted by callee-caller order (i.e. </p>
<p>callees without callers first). Store the map of FuncOp to all its callers in <code>callerMap</code>. Return <code><a class="el" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4" title="Utility function to generate a LogicalResult. ">failure()</a></code> if a cycle of calls is detected or if we are unable to retrieve the called FuncOp from any CallOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01449">1449</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01628">mlir::linalg::comprehensive_bufferize::runComprehensiveBufferize()</a>.</p>

</div>
</div>
<a id="a0dc199860e7feb8dd45b81ea38cc3738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc199860e7feb8dd45b81ea38cc3738">&#9670;&nbsp;</a></span>getOrCreateBufferizedFunctionType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FunctionType getOrCreateBufferizedFunctionType </td>
          <td>(</td>
          <td class="paramtype">FuncOp&#160;</td>
          <td class="paramname"><em>funcOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>argumentTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>resultTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; FuncOp, FunctionType &gt; &amp;&#160;</td>
          <td class="paramname"><em>bufferizedFunctionTypes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If an entry for <code>funcOp</code> is available in <code>bufferizedFunctionTypes</code>, return it. </p>
<p>Otherwise, construct a new entry based on <code>argumentTypes</code> and <code>resultTypes</code>. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00741">741</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00720">getBufferizedFunctionType()</a>, and <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00140">LDBG</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00875">bufferize()</a>, and <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01311">bufferizeFuncOpBoundary()</a>.</p>

</div>
</div>
<a id="aab55113efa4ab370f96475cb0704060c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab55113efa4ab370f96475cb0704060c">&#9670;&nbsp;</a></span>happensBefore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool happensBefore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>domInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if <code>a</code> happens before <code>b</code>, i.e., <code>a</code> or one of its ancestors properly dominates <code>b</code> and <code>b</code> is not inside <code>a</code>. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00388">388</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Operation_8h_source.html#l00117">mlir::Operation::getParentOp()</a>, <a class="el" href="Operation_8cpp_source.html#l00228">mlir::Operation::isProperAncestor()</a>, and <a class="el" href="Dominance_8h_source.html#l00130">mlir::DominanceInfo::properlyDominates()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00409">hasReadAfterWriteInterference()</a>.</p>

</div>
</div>
<a id="ae6eadad09fb96d71e21048100a61fce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6eadad09fb96d71e21048100a61fce7">&#9670;&nbsp;</a></span>hasMatchingExtractSliceOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hasMatchingExtractSliceOp </td>
          <td>(</td>
          <td class="paramtype">const BufferizationAliasInfo &amp;&#160;</td>
          <td class="paramname"><em>aliasInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InsertSliceOp&#160;</td>
          <td class="paramname"><em>insertOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if <code>value</code> is originating from an ExtractSliceOp that matches the given InsertSliceOp. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00373">373</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00291">areEquivalentExtractSliceOps()</a>, and <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00273">mlir::linalg::comprehensive_bufferize::findValueInReverseUseDefChain()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00409">hasReadAfterWriteInterference()</a>.</p>

</div>
</div>
<a id="ad6479fb8e380d763b6e27bd6445f2f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6479fb8e380d763b6e27bd6445f2f85">&#9670;&nbsp;</a></span>hasReadAfterWriteInterference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool hasReadAfterWriteInterference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>usesRead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>usesWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>domInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BufferizationAliasInfo &amp;&#160;</td>
          <td class="paramname"><em>aliasInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given sets of uses and writes, return true if there is a RaW conflict under the assumption that all given reads/writes alias the same buffer and that all given writes bufferize inplace. </p>
<p>A conflict is: According to SSA use-def chains, a read R is supposed to read the result of a write W1. But because of bufferization decisions, R actually reads another write W2. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00409">409</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00109">mlir::Value::cast()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00300">mlir::linalg::comprehensive_bufferize::findLastPrecedingWrite()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00187">mlir::linalg::comprehensive_bufferize::getAliasingOpResult()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00388">happensBefore()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00373">hasMatchingExtractSliceOp()</a>, <a class="el" href="Dialect_2SCF_2SCF_8cpp_source.html#l01013">mlir::scf::insideMutuallyExclusiveBranches()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00140">LDBG</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00245">printOperationInfo()</a>, and <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00266">printValueInfo()</a>.</p>

</div>
</div>
<a id="a0389e3ab6c3f6d8ed10a1ffd389b73df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0389e3ab6c3f6d8ed10a1ffd389b73df">&#9670;&nbsp;</a></span>inPlaceAnalysisFuncOpBody()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> inPlaceAnalysisFuncOpBody </td>
          <td>(</td>
          <td class="paramtype">FuncOp&#160;</td>
          <td class="paramname"><em>funcOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BufferizationAliasInfo &amp;&#160;</td>
          <td class="paramname"><em>aliasInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>domInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>analysisFuzzerSeed</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Analyze the <code>funcOp</code> body to determine which OpResults are inplaceable. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01126">1126</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Operation_8h_source.html#l00266">mlir::Operation::getOperandTypes()</a>, <a class="el" href="Operation_8h_source.html#l00297">mlir::Operation::getResultTypes()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l00382">mlir::BoolAttr::getValue()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00152">isaTensor()</a>, and <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00140">LDBG</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01628">mlir::linalg::comprehensive_bufferize::runComprehensiveBufferize()</a>.</p>

</div>
</div>
<a id="a5d3f4227b727bd0d4df109e86e0b1bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3f4227b727bd0d4df109e86e0b1bab">&#9670;&nbsp;</a></span>isaTensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isaTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00152">152</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00234">mlir::Type::isa()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizableOpInterface_8h_source.html#l00348">mlir::linalg::comprehensive_bufferize::AllocationHoistingBarrierOnly&lt; OpTy &gt;::bufferize()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00875">bufferize()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01759">mlir::linalg::comprehensive_bufferize::arith_ext::ConstantOpInterface::bufferize()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01311">bufferizeFuncOpBoundary()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01214">bufferizeFuncOpInternals()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01184">mlir::linalg::comprehensive_bufferize::bufferizeOp()</a>, and <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01126">inPlaceAnalysisFuncOpBody()</a>.</p>

</div>
</div>
<a id="a6d759a8c6c40b0736e6c57c07b377805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d759a8c6c40b0736e6c57c07b377805">&#9670;&nbsp;</a></span>isInplaceMemoryWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool isInplaceMemoryWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>opOperand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BufferizationAliasInfo &amp;&#160;</td>
          <td class="paramname"><em>aliasInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if opOperand has been decided to bufferize in-place. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00303">303</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00210">mlir::linalg::comprehensive_bufferize::bufferizesToMemoryWrite()</a>, and <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00187">mlir::linalg::comprehensive_bufferize::getAliasingOpResult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00349">aliasesInPlaceWrite()</a>.</p>

</div>
</div>
<a id="a91e4e097aa4d933636c66131e3955068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e4e097aa4d933636c66131e3955068">&#9670;&nbsp;</a></span>layoutPostProcessing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> layoutPostProcessing </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>moduleOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Postprocess the linalg.buffer_layout annotation across function boundaries. </p>
<p>This is a purely mechanical process that may later become part of a separate pass with its own layout assignment heuristic. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01513">1513</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01628">mlir::linalg::comprehensive_bufferize::runComprehensiveBufferize()</a>.</p>

</div>
</div>
<a id="afafb910b9297e1def2d183b2ff15d7bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afafb910b9297e1def2d183b2ff15d7bd">&#9670;&nbsp;</a></span>moveInsertionPointToAllocationHoistingBarrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> moveInsertionPointToAllocationHoistingBarrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move the insertion point of the given builder to the beginning of a surrounding block as much as possible, while not crossing any allocation hoisting barriers. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00762">762</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="IR_2Region_8h_source.html#l00045">mlir::Region::getBlocks()</a>, <a class="el" href="Builders_8h_source.html#l00375">mlir::OpBuilder::getInsertionBlock()</a>, <a class="el" href="Operation_8h_source.html#l00420">mlir::Operation::getNumRegions()</a>, <a class="el" href="Block_8cpp_source.html#l00030">mlir::Block::getParentOp()</a>, <a class="el" href="Operation_8h_source.html#l00117">mlir::Operation::getParentOp()</a>, <a class="el" href="Operation_8h_source.html#l00429">mlir::Operation::getRegion()</a>, and <a class="el" href="Builders_8h_source.html#l00364">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00791">getAllocationTypeAndShape()</a>.</p>

</div>
</div>
<a id="a2d3c9a4bae960942ab47f607c4356d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3c9a4bae960942ab47f607c4356d2f">&#9670;&nbsp;</a></span>printOperationInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string printOperationInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the operation name and bufferization information. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00245">245</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00132">DEBUG_TYPE</a>, <a class="el" href="Operation_8h_source.html#l00057">mlir::Operation::getName()</a>, <a class="el" href="Operation_8h_source.html#l00252">mlir::Operation::getOpOperands()</a>, <a class="el" href="Operation_8h_source.html#l00289">mlir::Operation::getOpResults()</a>, <a class="el" href="Operation_8h_source.html#l00120">mlir::Operation::getParentOfType()</a>, and <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00235">printTensorOrBufferInfo()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00349">aliasesInPlaceWrite()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00409">hasReadAfterWriteInterference()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00266">printValueInfo()</a>, and <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00192">setInPlaceOpResult()</a>.</p>

</div>
</div>
<a id="a141e0eb8c47839d63c212e47a42036dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141e0eb8c47839d63c212e47a42036dd">&#9670;&nbsp;</a></span>printTensorOrBufferInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> printTensorOrBufferInfo </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AsmState.html">AsmState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper method printing the bufferization information of a buffer / tensor. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00235">235</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00119">mlir::Value::getType()</a>, <a class="el" href="Types_8h_source.html#l00234">mlir::Type::isa()</a>, and <a class="el" href="AsmPrinter_8cpp_source.html#l02808">mlir::Value::printAsOperand()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00245">printOperationInfo()</a>, and <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00266">printValueInfo()</a>.</p>

</div>
</div>
<a id="a5fc47e96095baa9f513e9dce23429adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc47e96095baa9f513e9dce23429adb">&#9670;&nbsp;</a></span>printValueInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string printValueInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the bufferization information for the defining op or block argument. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00266">266</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2Region_8h_source.html#l00199">mlir::Region::getParentOfType()</a>, <a class="el" href="Value_8cpp_source.html#l00041">mlir::Value::getParentRegion()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00245">printOperationInfo()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00235">printTensorOrBufferInfo()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00161">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00349">aliasesInPlaceWrite()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00314">aliasesNonWritableBuffer()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01039">bufferizableInPlaceAnalysisImpl()</a>, and <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00409">hasReadAfterWriteInterference()</a>.</p>

</div>
</div>
<a id="adb7ec3aad9a13c917e7cd1b32be02673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7ec3aad9a13c917e7cd1b32be02673">&#9670;&nbsp;</a></span>removeBufferizationFuncArguments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> removeBufferizationFuncArguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a>&#160;</td>
          <td class="paramname"><em>bbArg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the attribute that triggers inplace bufferization on a FuncOp argument <code>bbArg</code>. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00221">221</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00312">mlir::BlockArgument::getArgNumber()</a>, <a class="el" href="Value_8h_source.html#l00309">mlir::BlockArgument::getOwner()</a>, and <a class="el" href="Block_8cpp_source.html#l00030">mlir::Block::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01628">mlir::linalg::comprehensive_bufferize::runComprehensiveBufferize()</a>.</p>

</div>
</div>
<a id="a11c2ce593ad805a35baa8c265938c01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c2ce593ad805a35baa8c265938c01c">&#9670;&nbsp;</a></span>setInPlaceFuncArgument()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> setInPlaceFuncArgument </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a>&#160;</td>
          <td class="paramname"><em>bbArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inPlace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the attribute that triggers inplace bufferization on a FuncOp argument <code>bbArg</code>. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00212">212</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00940">mlir::BoolAttr::get()</a>, <a class="el" href="Value_8h_source.html#l00312">mlir::BlockArgument::getArgNumber()</a>, <a class="el" href="Value_8h_source.html#l00122">mlir::Value::getContext()</a>, <a class="el" href="Value_8h_source.html#l00309">mlir::BlockArgument::getOwner()</a>, and <a class="el" href="Block_8cpp_source.html#l00030">mlir::Block::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01613">annotateOpsWithBufferizationMarkers()</a>.</p>

</div>
</div>
<a id="aa1109d802a5aa2a34cf74919ab5fc16e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1109d802a5aa2a34cf74919ab5fc16e">&#9670;&nbsp;</a></span>setInPlaceOpResult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classvoid.html">void</a> setInPlaceOpResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a>&#160;</td>
          <td class="paramname"><em>opResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inPlace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark whether OpResult can actually be bufferized inplace. </p>
<p>If <code>inPlace</code> is <code>true</code>, the use-def chain analysis has guaranteed that no subsequent write would occur to the bufferized tensor value (i.e. the result can be bufferized inplace). </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00192">192</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00123">mlir::Attribute::dyn_cast_or_null()</a>, <a class="el" href="Operation_8h_source.html#l00323">mlir::Operation::getAttr()</a>, <a class="el" href="Operation_8h_source.html#l00273">mlir::Operation::getNumResults()</a>, <a class="el" href="Value_8h_source.html#l00434">mlir::OpResult::getOwner()</a>, <a class="el" href="Value_8h_source.html#l00437">mlir::OpResult::getResultNumber()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00186">kInPlaceResultsAttrName</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00140">LDBG</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00245">printOperationInfo()</a>, and <a class="el" href="Operation_8h_source.html#l00347">mlir::Operation::setAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01613">annotateOpsWithBufferizationMarkers()</a>.</p>

</div>
</div>
<a id="a67ee262184fc2f887d47e1f244dbf965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ee262184fc2f887d47e1f244dbf965">&#9670;&nbsp;</a></span>wouldCreateReadAfterWriteInterference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wouldCreateReadAfterWriteInterference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a>&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>domInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BufferizationAliasInfo &amp;&#160;</td>
          <td class="paramname"><em>aliasInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkConsistencyOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if bufferizing result inplace would create a conflict. </p>
<p>A read R and a write W of the same alias set is a conflict if inplace bufferization of W changes the value read by R to a value different from the one that would be expected by tracing back R's origin through SSA use-def chains. A conflict can only be introduced by a new alias and/or an inplace bufferization decision.</p>
<p>Example: %0 = tensor.extract_slice t[...][...][1, 1] {inplace?} %1 = vector.transfer_write v1, t {inplace} : vector&lt;5xf32&gt;, tensor&lt;?xf32&gt; e = tensor.extract_slice %1 %2 = vector.transfer_write v2, %0 {inplace} : vector&lt;6xf32&gt;, tensor&lt;?xf32&gt; %3 = vector.transfer_read e, cst : tensor&lt;?xf32&gt;, vector&lt;7xf32&gt;</p>
<p>In the above example, the two TransferWriteOps have already been decided to bufferize inplace. Bufferizing the ExtractSliceOp inplace would create a conflict because:</p><ul>
<li>According to SSA use-def chains, we expect to read the result of %1.</li>
<li>However, adding an alias {%0, t} would mean that the second TransferWriteOp overwrites the first one. Therefore, the TransferReadOp would no longer be reading the result of %1.</li>
</ul>
<p>If <code>checkConsistencyOnly</code> is true, this function checks if there is a read-after-write conflict without bufferizing <code>operand</code> inplace. This would indicate a problem with the current inplace bufferization decisions. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00583">583</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00178">mlir::linalg::comprehensive_bufferize::getAliasingOpOperand()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01039">bufferizableInPlaceAnalysisImpl()</a>, and <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01593">checkAliasInfoConsistency()</a>.</p>

</div>
</div>
<a id="acd8b7f82fa1f60734f2f366239036a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8b7f82fa1f60734f2f366239036a80">&#9670;&nbsp;</a></span>wouldCreateWriteToNonWritableBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool wouldCreateWriteToNonWritableBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>opOperand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a>&#160;</td>
          <td class="paramname"><em>opResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BufferizationAliasInfo &amp;&#160;</td>
          <td class="paramname"><em>aliasInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if bufferizing <code>opOperand</code> inplace with <code>opResult</code> would create a write to a non-writable buffer. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00628">628</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00349">aliasesInPlaceWrite()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00314">aliasesNonWritableBuffer()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00210">mlir::linalg::comprehensive_bufferize::bufferizesToMemoryWrite()</a>, <a class="el" href="UseDefLists_8h_source.html#l00133">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00178">mlir::linalg::comprehensive_bufferize::getAliasingOpOperand()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01261">getEquivalentAlloc()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01278">getEquivalentEnclosingFuncBBArg()</a>, <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00140">LDBG</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00161">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l01039">bufferizableInPlaceAnalysisImpl()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a660646289e735830b2490d50e78de988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a660646289e735830b2490d50e78de988">&#9670;&nbsp;</a></span>kInPlaceResultsAttrName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr StringLiteral kInPlaceResultsAttrName = &quot;__inplace_results_attr__&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attribute marker to specify op results that can be bufferized inPlace. </p>

<p class="definition">Definition at line <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00186">186</a> of file <a class="el" href="ComprehensiveBufferize_8cpp_source.html">ComprehensiveBufferize.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ComprehensiveBufferize_8cpp_source.html#l00192">setInPlaceOpResult()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Nov 17 2021 20:34:50 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
